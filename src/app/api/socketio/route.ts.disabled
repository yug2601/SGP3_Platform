/**
 * Next.js API route to expose a Socket.IO server instance.
 * It ensures the server is created only once (stored on the global object)
 * to avoid re-instantiation on every hot reload in development.
 */

import type { NextRequest } from 'next/server'
import { NextResponse } from 'next/server'
import type { Server as HTTPServer } from 'http'
import type { Socket as NetSocket } from 'net'
import type { Server as IOServer } from 'socket.io'
import { Server } from 'socket.io'

type NextSocketServer = {
  io?: IOServer
}

declare global {
  // Extend the global object to cache our Socket.IO instance across reloads
  var _togetherflowSocket: NextSocketServer | undefined
}

function getOrCreateIOServer(server: HTTPServer | undefined) {
  const globalSocket = global._togetherflowSocket ?? { io: undefined }

  if (globalSocket.io && globalSocket.io.httpServer.listening) {
    return globalSocket.io
  }

  if (!server) {
    throw new Error('No HTTP server instance available to attach Socket.IO')
  }

  const io = new Server(server, {
    path: '/api/socketio',
    addTrailingSlash: false,
    cors: {
      origin: '*',
      methods: ['GET', 'POST'],
    },
  })

  globalSocket.io = io
  global._togetherflowSocket = globalSocket
  return io
}

export const dynamic = 'force-dynamic'
export const runtime = 'edge'

export async function GET(request: NextRequest) {
  const res = NextResponse.json({ ready: true })
  const upgradeHeader = request.headers.get('upgrade')

  if (upgradeHeader && upgradeHeader.toLowerCase() === 'websocket') {
    return new Response(null, { status: 426, statusText: 'Upgrade Required' })
  }

  const anyRes = res as unknown as { socket?: NetSocket & { server?: HTTPServer } }
  const nodeServer = anyRes.socket?.server

  if (!nodeServer) {
    return new NextResponse('Socket server unavailable', { status: 500 })
  }

  getOrCreateIOServer(nodeServer)
  return res
}